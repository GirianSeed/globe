[SCE CONFIDENTIAL DOCUMENT]
"PlayStation 2" Programmer Tool Runtime Library Release 2.5.3
                  Copyright (C) 2001 Sony Computer Entertainment Inc.
                                                     All Rights Reserved  

Collision Detection Sample

Overview:
--------
This sample uses an implementation of a narrow-phase collision detection 
technique(GJK). This technique is efficiently used if a very accurate 
collision detection is needed (e.g.: rigid body simulation). Also a 
broad-phase collision detection algorithm (like "Sweep and Prune")
should be used to identify the possible collision candidates if the 
number of objects is high.

Two main functions are implemented:

is_collision().. checks if two objects intersect or not.
calc_dist()... calculates the closest distance^2 between two objects.

The used algorithm works only for convex objects but more interesting
objects can be generated using a hierarchy of convex sub-objects.

For the rendering process the HiG/HiP library is used.
 
Algorithm:
----------
The algorithm used for this sample is the GJK(Gilbert-Johnson-Keerthi)
Algorithm(See [1] for details). 

The implementation of the GJK algorithm in this sample uses
a slightly different approach than described in [1]:

The GJK algorithm uses the concept of the 
Minkowski-sum to define the distance between two bodies A and B .The 
Minkowski-sum is actually a "difference":   

A-B={x-y:x is an element of Body A,y is an element of Body B}

If the origin (0,0,0) lies inside the Minkowski-sum,then the two bodies
are intersecting.

The algorithm tests if  a simplex(consisting of up to 4 points of the 
Minkowski-sum)contains the origin in its convex hull. If not, then it 
calculates the smallest subset (<=3 points) of the simplex, which 
contains the closest point to the origin in its convex hull. The 
algorithm searches the Minkowski-sum for the closest simplex to the 
origin and stops, if either the origin is found to lie in the 
Minkowski-sum(objects are intersecting -> distance is 0) or the closest
Minkowski-simplex to the origin is found.


To calculate the smallest subset of a given simplex,which contains the 
closest point to the origin in its convex hull, a different approach 
than in the GJK paper[1] described is used. It borrows ideas from Eric 
Larsen(SCEA,R&D)[2] and applies it to the case of a Minkowski-simplex
(Eric uses a simplex-pair instead of the Minkowski-sum). In this 
approach the Vu0 is used to check if a line-segment is the the smallest 
subset to the origin. The Vu0 is working in micro-mode so this approach 
has the advantage that if the simplex consists of more than 2 points the
CPU can check if a triangle is the closest subset while the Vu0 checks 
the line-segments at the SAME time.


Usage:
-------
1.Because this implementation of the GJK algorithm uses the Vu0 in
micro-mode, the code has to be loaded into Vu0-program memory with the 
collision_init() function. A vcl-version of the micro-code is in 
vu0coll.vcl .

2.The user has to initialize one "Simplex"-structure per collision pair 
and one "GJKObj"-structure for each collision object. This is done in the 
sample with the gjk_init() function.

Simplex members which need to be initialized:
   - cache_valid .. set it to 0 to tell the algorithm not to reuse the 
		    result of the previous frame as a starting-point for
                    the search for the closest feature. Reusing the 
                    simplex of the previous frame as a starting guess 
                    usually speeds up the calculation if the frame 
                    coherency is high. So this parameter should be set
		    0 only if the result of the previous frame is not 
                    valid (e.g: for the first frame).		       
   - epsilon .. calculation precision
   - hintA,hintB ... is a hint to the vertex index of the GJKObj where 
                     the closest features might be. This parameter is 
                     only valid if the corresponding GJKObj is from type
                     GJK_MESH.
		

GJKObj members which need to be initialized:
   - type .. can be GJK_BOX,GJK_SPHERE,GJK_CONE,GJK_CYLINDER or GJK_MESH.
   - lw ..  the objects local_world matrix
   - lwrot .. the object light_rot matrix
	
     if type is not GJK_MESH then:
       radius,half_length are used to define the geometry for a cylinder,
                          sphere or cone object.
       half_box is used to define the geometry of the box object.
	
       GJK_SPHERE: radius ... radius of the sphere
       GJK_CONE: radius ... radius of the cone base
                 half_length ... (height of the cone)/2 
       GJK_CYLINDER: radius ... radius of the cylinder base
                     half_length ... (height of the cylinder)/2
       GJK_BOX: half_box[0] ... (length of the box)/2 in x-direction
                half_box[1] ... (length of the box)/2 in y-direction
                half_box[2] ... (length of the box)/2 in z-direction

If a polygon mesh(GJK_MESH) is used then a nearest neighbor table is used
to speed up the algorithm.

To allocate this table :

int alloc_gjkobj_neighbors(void *gjk_data_addr,GJKObj *gjkobj);

can be used.

To create the nearest neighbor table a gjkobj-file is used
(the format is explained below).  
gjk_data_addr points to the data in the gjkob-file (which contains the convex
hull vertices of the mesh and the nearest neighbor list). 

To free the allocated table use:
void free_gjkobj_neighbors(GJKObj *gjkobj); 


3.Now 
int  is_collision(Simplex *simplex,GJKObj *gjkobjA,GJKObj *gjkobjB);
(the return value is 0/1 for no_collision/collision)

or

float calc_dist(Simplex *simplex,GJKObj *gjkobjA,GJKObj *gjkobjB,u_int calc_points);
(the return value is the distance^2 between the objects)

can be used to test if objects are intersecting or to calculate the 
closest distance between objects. The parameter calc_points selects if 
also the closest points defined in the local-coordinate systems of the 
bodies should be calculated. The result is in simplex->closest_pointA and
simplex->closest_pointB. 

calc_points=1.. calculate closest points
           =0.. closest points are not calculated


gjkobj-file-format :
--------------------
.word num_of_vertices,0,0,0
.float vertex0
.float vertex1
    .
    .
.float vertexN
.word total_umber_of_neighbors,0,0,0
.word num_of_neighbors_of_vertex0,neighbor0,neighbor1,....,neighborN
  .
  .
.word num_of_neighbors_of_vertexN,neighbor0,....,neighborN

The gjkobj-file for a simple flat plane would look like:

.word 4,0,0,0
.float -10.000000,0.000000,-10.000000,1.0
.float 10.000000,0.000000,-10.000000,1.0
.float 10.000000,0.000000,10.000000,1.0
.float -10.000000,0.000000,10.000000,1.0
.word 8,0,0,0
.word 2,1,3,2 
.word 0,2,2,1 
.word 3,2,0,2

a random neighbor can be added to the neighbor list, which might 
accelerate the search algorithm.

Future work:
-------------
1.Optimization of the algorithm
2.Implementation of a broad phase collision algorithm

References:
------------
[1] van den Bergen,Gino "A Fast and Robust GJK Implementation for 
Collision Detection of Convex Objects",1999,Journal of Graphics Tools, 4(2):7-25, 1999 
[2] Larsen,Eric "A Robot Soccer Simulation: A Case Study for 
Rigid Body Contact",GDC,2001
